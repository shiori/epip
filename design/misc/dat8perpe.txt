// PE process eight data once time
// per PE process N/P data totaly
// assume that data has been bit-reversed
// and stored in shared memory. The data organization is as follows(32 data for example):
// 0~7 8~15 are stored in bank0  16~23 24~31 are stored in bank1
// only two PE for example.
// if there are 1024 point, logic PE num is 32, the number assigned to PE is 1024/32=32
// 0~31->bank0 32~63->bank1 64~95->bank2 96~127->bank3 ...... 992~1023->bank31
// the twiddle factors has been computed and stored in shared memory
// m=log2(1024)
li s8 10 ;
// fix_dn
li s0 8 ;
// dn_pe
li s1 32 ;
// log2(dn_pe)-1
li s2 4 ;
// iter = dn_pe/fix_dn
li s3 4 ;
// constant 1
li s5 1 ;
// e
li s4 0 ;
// step l
srl s5 s5 s4 ;
// tmp variable ff
li s6 0 ;
// e+1
add s7 s4 1 ;

// initialize the PE ID
vid v0 ;
// the memory bank address PE0->BANK0 PE1->BANK1 PE2->BANK2
// 00000_00, 00001_00; 00010_00;.....
sll v0 v0 2 ;

$loop1
// ff * fix_dn  0<=ff<iter
mul s9 s6 s0 ;
sll s10 s9 7 ;
// data real part
add.u v1 v0 s10 ;
// data imag part
add.u v2 v0 0x1000 ;
// WNP_adr real part
add.u v3 v0 0x2000 ;
// WNP_adr imag part
add.u v4 v0 0x10000 ;

// the first data real part
ld.word.rand v10 v1 0 ;
// the second data real part
ld.word.rand v11 v1 128 ;
// the third data real part
ld.word.rand v12 v1 256 ;
// the fourth data real part
ld.word.rand v13 v1 384 ;
// the fifth data real part
ld.word.rand v14 v1 512 ;
// the sixth data real part
ld.word.rand v15 v1 640 ;
// the seventh data real part
ld.word.rand v16 v1 768 ;
// the eigth data real part
ld.word.rand v17 v1 896 ;

// the first data imag part
ld.word.rand v20 v2 0 ;
// the second data imag part
ld.word.rand v21 v2 128 ;
// the third data imag part
ld.word.rand v22 v2 256 ;
// the fourth data imag part
ld.word.rand v23 v2 384 ;
// the fifth data imag part
ld.word.rand v24 v2 512 ;
// the sixth data imag part
ld.word.rand v25 v2 640 ;
// the seventh data imag part
ld.word.rand v26 v2 768 ;
// the eigth data imag part
ld.word.rand v27 v2 896 ;

// compute the bf
// the first level
// WNP_adr

ld.word.rand v28


cmp.unc.< p1 p0 s6 s3 ; 
(p1) add.u s6 s6 1 ;
(p1) b.naz.bc.pop2n $loop1 0 ;

















// ff
li v1 0 ;

// ff*fix_dn
mul v1 v1 s0 ;
// ff*fix_dn + k
add.u v2 v1 s6 ;

// pe_id*dn_pe + ff*fix_dn + k
mad.u v3 v0 s1 v2 ;

// v4 res = mod(pe_id*dn_pe + ff*fix_dn + k,l)
sll v4 v3 s4 ;
sub v4 v3 v4 ;
// v5 mod(pe_id*dn_pe + ff*fix_dn + k,2*l)
sll v5 v3 s7 ;
sub v5 v3 v5 ;

// mod(i*dn_pe+ff*fix_dn+k,l)==mod(i*dn_pe+ff*fix_dn+k,2*l)
cmp.unc.= p1 p0 v4 v5 ;

// v6 WNP_adr res*2^(m-(e+1))
(p1) sub s9 s8 s7 ;
(p1) sll v6 v4 s9 ;

// v7 the first data v2->offset, v
(p1) ld.word.rand v6  v2 ;
// ff*fix_dn + k + l
(p1) add.u v7 v2 s5 ;
// v7->offset
(p1) ld.word.rand v8  v7 ;









